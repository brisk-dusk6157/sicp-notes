#+PROPERTY: header-args  :cache yes
#+PROPERTY: header-args+  :exports code
#+PROPERTY: header-args+  :noweb strip-export
#+TITLE: 3 Modularity, Objects and State
#+options: num:nil

* Intro

In previous chapters we introduced:
- basic elements from which programs are made
- how to combine primitives to construct compound entities
- abstraction is vital to cope with complexity of large systems

But these are not sufficient for designing programs.

Effective program synthesis also requires an organizational principles that can guide us in formulating overall design of the system.


Effective program synthesis requires organizational principles that can guide us in formulating overall design of a program.

In particular, we need strategies to help us structure large system so the they are /modular/, that is, so that they are divided "naturally" into coherent parts that can be developed and maintained separately.

One (what are the others Gerald??) powerful design strategy, is to base the structure of a program on the structure of the system being modelled. For each object in the system we construct corresponding computational object. For each system action we define a symbolic operation in our computational model.

Our hope in using this strategy is that extending the model to accomodate new objects or new actions will require no strategic changes to the program, only the addition of the new symbolic analogs of those objects or actions. If we are successful in our system organization, then to add a new feature or debug an old one we will have to work in a localized part of the system.

To a large extent the way we orgnize programs depends on our perception of the systems being modelled. In this chapter we will investigate two organizational strategies arising from two different "world views" of the structure of systems.

First organizational strategy concentrates on /objects/, viewing a large system as a collection of objects whose behavior may change over time.

An alternative organizational strategy concentrates on the /streams/ of information that flow in the system.

* 3.1 Assignment and Local State

We ordinarily view the world as populated by independent objects, each of which has a state that changes over time. An object is said to "have state" if its history influences its behavior. Object's state can be characterized by one or more /state variables/.

In a system composed of many objects, the objects are rarely completely independent. Each may influence the states of others through interactions, which servie to couple the state variables of one object to those of another.

If we choose to model the flow of time in the system by the elapsed time in the computer, then we must have a way to construct computational objects whose behaviors change as our programs run.

** 3.1.1 Local State Variables

#+begin_src racket
  (define balance 100)

  (define (withdraw amount)
    (if (>= balance amount)
	(begin (set! balance (- balance amount))
	       balance)
	"Insufficient funds"))
#+end_src

~balance~ is global and could be modified by anyone,

#+begin_src racket
  (define new-withdraw
    (let ((balance 100))
      (lambda (amount)
	(if (>= balance amount)
	    (begin (set! balance (- balance amount))
		   balance)
	    "Insufficient funds"))))
#+end_src

#+begin_src racket
  #lang sicp

  (define (make-withdraw balance)
    (lambda (amount)
      (if (>= balance amount)
	  (begin (set! balance (- balance amount))
		 balance)
	  "Insufficient funds")))

  (define W1 (make-withdraw 100))
  (define W2 (make-withdraw 100))
  (W1 50)
  (W2 70)
#+end_src

#+RESULTS:
: 50
: 30


#+begin_src racket
  #lang sicp

  (define (make-account balance)
    (define (withdraw amount)
      (if (>= balance amount)
	  (begin (set! balance (- balance amount))
		 balance)
	  "Insufficient funds"))
    (define (deposit amount)
      (set! balance (+ balance amount))
      balance)
    (define (dispatch m)
      (cond ((eq? m 'withdraw) withdraw)
	    ((eq? m 'deposit) deposit)
	    (else (error "Unknown request -- MAKE-ACCOUNT" m))))
    dispatch)

  (define a (make-account 0))

  ((a 'deposit) 100)
  ((a 'deposit) 50)
  ((a 'withdraw) 120)
  ((a 'withdraw) 100)
  ((a 'withdraw) 30)
#+end_src

#+RESULTS:
: 100
: 150
: 30
: "Insufficient funds"
: 0

*** Exercise 3.1 - accumulator

An /accumulator/ is a function of one numeric argument, when called repeatedly accumulates it's arguments into a sum. Each time it is called it returns the currently accumulated sum.

#+begin_src racket
  (define (make-accumulator sum)
    (lambda (arg)
      (set! sum (+ sum arg))
      sum))

  (define acc (make-accumulator 10))
  (acc 20)
  (acc 30)
#+end_src

#+RESULTS:
: 30
: 60

*** Exercise 3.2 - ~make-monitored~ 

Write a procedure ~make-monitored~ that takes as input a procedure, f, that itself takes one input. The result returned by ~make-monitored~ is a third procedure, say ~mf~, tat keeps track of the number of times it has been called by maintaining an internal counter.

If the input to ~mf~ is the special symbol ~how-many-calls?~, then ~mf~ returns the value of the counter.
If the input to ~mf~ is the special symbol ~reset-count~ them ~mf~ resets the counter to zero.

#+name: make-monitored
#+begin_src racket
  (define (make-monitored f)
    (let ((cnt 0))
      (define (mf x)
	(cond ((eq? x 'how-many-calls?) cnt)
	      ((eq? x 'reset-counter)
	       (set! cnt 0)
	       cnt)
	      (else
	       (set! cnt (+ 1 cnt))
	       (f x))))
      mf))
#+end_src

#+begin_src racket
  <<make-monitored>>
  (define s (make-monitored sqrt))
  (s 100)
  (s 'how-many-calls?)
  (s 10)
  (s 10)
  (s 10)
  (s 10)
  (s 'how-many-calls?)
  (s 'how-many-calls?)
  (s 'how-many-calls?)
  (s 'reset-counter)
  (s 'how-many-calls?)
#+end_src

#+RESULTS[cb07b658eb44e32f132f957ce6cb85f0a41cd91f]:
#+begin_example
10
1
3.1622776601683795
3.1622776601683795
3.1622776601683795
3.1622776601683795
5
5
5
0
0
#+end_example

*** Exercise 3.3 - password-protected accounts

#+begin_src racket
  (define (make-account amount password)
    (define (withdraw a)
      (begin
	    (if (> amount a)
		(begin
		  (set! amount (- amount a))
		  amount)
		"Insufficient funds")))
    (define (deposit a)
      (begin
	    (set! amount (+ amount a))
	    amount))
    (define (incorrect-password a)
      "Incorrect password")
    (define (dispatch p m)
      (if (eq? p password)
	  (cond ((eq? m 'withdraw) withdraw)
		((eq? m 'deposit) deposit))
	  incorrect-password))
    dispatch)

  (define acc (make-account 100 'secret))
  ((acc 'secret 'withdraw) 10)
  ((acc 'secret 'deposit) 100)
  ((acc 'secret 'withdraw) 1000)
  ((acc 'pecret 'withdraw) 190)
#+end_src

#+RESULTS[7ac702e984957d71bf51384924e7595096e5f047]:
: 90
: 190
: "Insufficient funds"
: "Incorrect password"

*** Exercise 3.4 - password-protected accounts with cops
#+begin_src racket
  (define (call-the-cops)
    (display "[police called]")
    (newline))

  (define (make-account amount password)
    (let ((incorrect-password-count 0))
      (define (withdraw a)
	(begin
	  (if (> amount a)
	      (begin
		(set! amount (- amount a))
		amount)
	      "Insufficient funds")))

      (define (deposit a)
	(begin
	  (set! amount (+ amount a))
	  amount))

      (define (dispatch p m)
	(if (not (eq? p password))
	    (begin
	      (set! incorrect-password-count (+ 1 incorrect-password-count))
	      (if (> incorrect-password-count 7)
		  (call-the-cops)
		  false)
	      (lambda (x) "Incorrect password"))
	    (begin
	      (set! incorrect-password-count 0)
	      (cond ((eq? m 'withdraw) withdraw)
		    ((eq? m 'deposit) deposit)))))
      dispatch))

  (define acc (make-account 100 'secret))
  ((acc 'secret 'withdraw) 10)
  ((acc 'secret 'deposit) 100)
  ((acc 'secret 'withdraw) 1000)
  ((acc 'pecret 'withdraw) 190)
  ((acc 'pecret 'withdraw) 190)
  ((acc 'pecret 'withdraw) 190)
  ((acc 'pecret 'withdraw) 190)
  ((acc 'pecret 'withdraw) 190)
  ((acc 'pecret 'withdraw) 190)
  ((acc 'pecret 'withdraw) 190)
  ((acc 'pecret 'withdraw) 190)
  ((acc 'pecret 'withdraw) 190)
  ((acc 'secret 'withdraw) 1000)
  ((acc 'pecret 'withdraw) 190)
#+end_src

#+RESULTS[6095577a4cbb3ecebb2010fd6d741228e93c0e62]:
#+begin_example
90
190
"Insufficient funds"
"Incorrect password"
"Incorrect password"
"Incorrect password"
"Incorrect password"
"Incorrect password"
"Incorrect password"
"Incorrect password"
[police called]
"Incorrect password"
[police called]
"Incorrect password"
"Insufficient funds"
"Incorrect password"
#+end_example

** 3.1.2 The Benefits of Introducing Assignment

Introducing assignment leads us into a thicket of difficult conceptual issues. Nevertheless, viewing our system as a collection of objects with local state is a powerful technique for maintaining a modular design.

Consider the design of a procedure ~rand~, that, whenever it is called, returns an integer chosen at random.

We want successive calls to ~rand~ to produce a sequence of numbers having certain statistical properties (uniform distribution).

To not focus on method of generating such sequences, assume we have a procedure ~rand-update~, such that ~x2 = (rand-update x1)~, ~x3 = (rand-update x2)~ and so on, where ~x1, x2, x3, ...~ sequence has the uniform distribution.

We can implement ~rand~ as a procedure with a local state variable ~x~:

#+begin_src racket
  (define rand
    (let ((x random-init))
      (lambda ()
	(set! x (rand-update x))
	x)))
#+end_src

Of course, we could generate the same sequence of random numbers without using local variable by simply calling ~rand-update~ directly. But then any part of our program that used random numbers would have to explicitly remember the current value of x to be passed as an argument to ~rand-update~.

Consider using random numbers to imlement a technique called /Monte Carlo simulation/.

The Monte Carlo method consists of choosing sample experiments at random from a large set and then making deductions on the basis of the probabilities estimated from tabulating the results of those experiments.

For example, we can appoximate $\pi$ using the fact that $6/\pi^2$ is the probability that two integers choosen at random will have no factors in common; that is that their gcd is 1. To obtain the approximation to $\pi$, we perform a large number of experiments. In each experiment we choose two integers at random and perform a test to see if their GCDs is 1. The fraction of times that the test is passed gives us our estimate of $6/\pi^2$.

#+begin_src racket :cache no :exports both
  #lang sicp

  (define (estimate-pi trials)
    (sqrt (/ 6 (monte-carlo trials cesaro-test))))

  (define (cesaro-test)
    (= (gcd (random 1000000000) (random 1000000000)) 1))

  (define (monte-carlo trials experiment)
    (define (iter trials-remaining trials-passed)
      (cond ((= trials-remaining 0)
	     (/ trials-passed trials))
	    ((experiment)
	     (iter (- trials-remaining 1) (+ trials-passed 1)))
	    (else
	     (iter (- trials-remaining 1) trials-passed))))
    (iter trials 0))

  (estimate-pi 10000000)
#+end_src

#+RESULTS[dc3f107fd2d248650762179c6f3f4a82733b35f7]:
: 3.1416712105610203

Alternatively, using ~rand-update~:

#+begin_src racket
  (define random-init 10)

  (define (estimate-pi trials)
    (sqrt (/ 6 (random-gcd-test trials random-init))))

  (define (random-gcd-test trials initial-x)
    (define (iter trials-remaining trials-passed x)
      (let ((x1 (rand-update x)))
	(let ((x2 (rand-update x1)))
	  (cond ((= trials-remaining 0)
		 (/ trials-passed trials))
		((= (gcd x1 x2) 1)
		 (iter (- trials-remaining 1)
		       (+ trials-passed 1)
		       x2))
		(else
		 (iter (- trials-remaining 1)
		       trials-passed
		       x2))))))
    (iter trials 0 initial-x))
#+end_src

In the version without local state, user code should manipulate the random numbers x1 and x2, and recycle x2 as the new input to ~rand-update~. The explicit handling of randomness intertwines with the experiment code, and greatly constricts the system with exactly 2 random numbers, making it impossible to reuse with 1 or 3.
Even ~esimtate-pi~ should be aware of this random system, by supplying ~random-init~.
All this makes it difficult to isolate the Monte Carlo idea so that it can be applied to other tasks.

In the first version assignment helps to encapsulate the state of the random-number generator withing the ~rand~ procedure, so that the details of random-number generation remaing independent of the rest of the program.

From the point of view of one part of a complex system, the other parts appear to change in time. They have hidden time-varying local state.

*** Exercise 3.5 - Monte Carlo integration

Space described by a predicate $P(x,y)$ that is true for all points inside the region and false otherwise.

To estimate the area of the region, begin by choosing a rectangle that contains the region. The desired integral is the area of that portion of the rectangle that lies in the region.
We can estimate the integral by picking, at random, points $(x, y)$ that lie in the rectangle, and testing $P(x,y)$ for each point. If we try this enough times, the fraction of points inside the region approximates the fraction of rectangle occupied be the region. Hence, multiplying this fraction by the area of the entire rectangle gives an estimate of the area of the region.

#+begin_src racket
  #lang sicp

  (define (random-in-range low high)
    (let ((range (- high low)))
      (+ low (random range))))

  (define (estimate-integral P x1 y1 x2 y2 trials)
    (define (experiment)
      (P (random-in-range x1 x2)
	 (random-in-range y1 y2)))  
    (* (- x2 x1)
       (- y2 y1)
       (monte-carlo trials experiment)))

  (define (monte-carlo trials experiment)
    (define (iter remaining passed)
      (cond ((zero? remaining)
	     (/ passed trials))
	    ((experiment)
	     (iter (- remaining 1) (+ passed 1)))
	    (else
	     (iter (- remaining 1) passed))))
    (iter trials 0))

  (define (square x) (* x x))

  (define (in-circle cx cy r)
    (lambda (x y)
      (< (+ (square (- x cx))
	    (square (- y cy)))
	 (square r))))

  (estimate-integral
   (in-circle 1.0 1.0 1.0)
   0.0
   0.0
   2.0
   2.0
   10000000)
#+end_src

#+RESULTS[dd07c87bda83eff35356c4d9b18b33b046ebe5d6]:
: 3.1423204

~monte-carlo~ is the same as used for Cesaro-based estimation, only experiment code differs.

*** Exercise 3.6 - rand reset

It is useful to be able to reset a random-number generator to produce a sequence starting from a given value.

Design a new ~rand~ procedure that is called with an argument that is either the symbol ~generate~ or ~reset~, and behaves as follows ~(rand 'generate)~ outputs a random value, and ~((rand 'reset) <new-value>)~ resets the internal state variable with the new-value.

#+begin_src racket
  (define (rand-update x)
    (remainder
     (+ (* 115249 x) 112909)
     108301))

  (define random-init 0)

  (define rand
    (let ((x random-init))
      (lambda (method)
	(cond ((eq? method 'generate)
	       (begin
		 (set! x (rand-update x))
		 x))
	      ((eq? method 'reset)
	       (lambda (n)
		 (set! x n)))
	      (else
	       (error "Unknown method -- RAND" method))))))
  (rand 'generate)
  (rand 'generate)
  (rand 'generate)
  (rand 'generate)
  (rand 'generate)
  ((rand 'reset) 0)
  (rand 'generate)
  (rand 'generate)
  (rand 'generate)
  
#+end_src

#+RESULTS[d2587f4d539b5b9aab043d34809928edc9b99898]:
: 4608
: 72197
: 87433
: 28783
: 65246
: 4608
: 72197
: 87433

** 3.1.2 The Costs of Introducing Assignment

As we have seen, the ~set!~ operation enables us to model objects that have local state. However, this advantage comes at a price.
Substitution model of procedure application is no longer adequate for interpreting programs. Moreover, no simple model with "nice" mathematical properties can be an adequate framework for dealing with objects and assignment in programming languages.

So long as we do not use assignments, two evaluations of the same procedures applied to the same arguments will produce the same results. Programming without any use of assignments is known as /functional programming/.

The trouble is that substitution is based ultimately on the notion that the symbols are essentially names for values.

> But as soon as we introduce ~set!~ and the idea the the value of a variable can change, a variable can no longer be simply a name.
Without ~set!~: name -> value.
With ~set!~: name -> variable -> value.

Now, variable refer to some place where the value is stored and can be changed. Environments play this role of "place".

*** Sameness and change

Introducing change into computational model renders what was previously straightforward as problematic. Consider the concept of two things being "the same".

Without ~set!~: if two values are created by the same expression, they are "the same", meaning they are computationally equivalent and can be substituted one for the other.
With ~set!~: even if two variables are created by the same expression, they are not "the same", they may have different histories, and hold different local state variables. The can /not/ be substituted one for the other.

A language that supports the concept that "equals can be substituted for equals" in an expressions without changing the value of expression is said to be /referentially transparent/.

Reasoning about the programs that contain assignment becomes drastically more difficult.

In real world, to decide if two apparently identical objects are the "same", one has to change one object and observe the other changed in the same way. But to determine if it's changed one has to observe "same" object at two distinct times, and detect some property change between two observations. Thus, we can not determine "change" without a priori notion of "sameness", and we cannot determine sameness without observing the change.

*** Pitfalls of imperative programming

Programming that makes extensive use of assignment is called /imperative programming/.

1. Order of assignment is significant.
2. Concurrent execution complicates things even more.

*** Exercise 3.7 - joint account

Define a procedue ~make-joint~ that takes three arguments:
- password-protected account
- auth password
- another password

, and returns an additional access to original account, protected by another password.

-----

One solution is to wrap ~dispatch~ definition in a function that accepts ~password~.

Probably a better one would be to provide a restricted version of dispatch to the joint account (e.g. without ~'make-joint~ method).

#+begin_src racket
  #lang sicp

  (define (make-account amount password)
    (define (withdraw a)
      (if (>= amount a)
	  (begin
	    (set! amount (- amount a))
	    amount)
	  "Insufficient funds"))
    (define (deposit a)
      (set! amount (+ amount a))
      amount)
    (define (make-dispatch password)
      (define (dispatch m p)
	(cond ((not (eq? p password))
	       (lambda (x) "Incorrect password"))
	      ((eq? m 'withdraw) withdraw)
	      ((eq? m 'deposit) deposit)
	      ((eq? m 'make-joint) make-dispatch)
	      (else
	       (error "Unknown method -- MAKE-ACCOUNT" m))))
      dispatch)
    (make-dispatch password))

  (define (make-joint acc verify-password new-password)
    ((acc 'make-joint verify-password) new-password))


  (define paul (make-account 100 'secret))
  ((paul 'withdraw 'secret) 10)
  (define peter (make-joint paul 'secret 'pecret))
  ((peter 'withdraw 'pecret) 90)
  ((paul 'withdraw 'secret) 10)
  (define pylyp (make-joint peter 'pecret 'qecret))
  ((pylyp 'deposit 'qecret) 100)
  ((paul 'withdraw 'secret) 10)
#+end_src

#+RESULTS[ffa55a4d0dd4de984587d21f6748b1f55a96ccda]:
: 90
: 0
: "Insufficient funds"
: 100
: 90


*** Exercise 3.8 - order of evaluation

Define a simple procedure ~f~ the evaluating ~(+ (f 0) (f 1))~ will return 0 if the arguments evaluated left to right, and 1 if the arguments evaluated right to left.

#+name: ex3.8-f
#+begin_src racket
  (define f
    (let ((s null))
      (lambda (x)
	(if (null? s)
	    (begin
	      (set! s x)
	      s)
	    0))))
#+end_src

#+RESULTS[c8cdbefd116f1d293a3e52f545f9f79b171813e5]: ex3.8-f

#+begin_src racket :noweb no-export :exports both
  <<ex3.8-f>>
  (+ (f 0) (f 1))
#+end_src

#+RESULTS[49b9a16d5d9d8ce1c14977f7e1c850b8f7330afb]:
: 0

#+begin_src racket :exports both
  <<ex3.8-f>>
  (+ (f 1) (f 0))
#+end_src

#+RESULTS[c7c909e12e1cd4a7f673e05b357d87287ba53969]:
: 1

* 3.2 The Environment Model of Evaluation

Substitution model of expression evaluation:

To apply a compound procedure, evaluate the body of the procedure with each formal parameter replaced with passed argument.

With assignment, the definition is no longer adequate. A variable can no longer be considered a name for a value. Rather, variable must somehow designate the place to store the value. In a new model evaluation, these places will be maintained in structures called /environments/.

An environment is a sequence of /frames/.

Each frame is a table (possible empty) of /bindings/, which associate the variable name with the corresponding value. A single frame can contain at most one binding for each variable.

Each frame stores a pointer to its /enclosing environment/, unless, the frame is considered to be /global/.

The /value of a variable/ w.r.t. an environment is the value given by the binding of the variable in the first frame in the environment that contains binding for that variable. If no frame in the sequence specifies a bindings for the variable, then the variable is said to be /unbound/ in the environment.

Expressions in a programming language have no meaning on its own, only within some environment where it's evaluated.

** 3.2.1 The Rules for Evaluation

The overall specification for how the interpreter evaluates a combination is not changed:
- evaluate the subexpressions of the combination
- apply the value of the operator subexpression to the values of the operand subexpressions

The environment model of evaluation replaces a substitution model in specifying what it means to apply a compound procedure to arguments.

In the environment model of evaluation, procedure is always a pair consisting of some code and a pointer to an environment. Procedures are created in one way only: by evaluating a lambda expression. This produces a procedure whose code is obtained from the text of the lambda expression, and whose environment is the environment in which the lambda expression was evaluated to produce a procedure.

In general, ~define~ (which is a syntactic sugar for ~lambda~) creates definitions by adding bindings to frames.

Knowing how procedures are created, here's how to apply a procedure according to environment model: To apply a procedure to arguments, create a new environment containing a frame that binds the parameters to the values of arguments. The enclosing environment of this frame is the environment specified by the procedure. Now, within a new environment evaluate the procedure body.

Summary for the environment model of procedure application:
- the procedure object is applied to a set of arguments by constructing a frame, binding the formal parameters to the values of the arguments of the call, and then evaluating the body of the procedure in the context of the new environment constructed
- a procedure is created by evaluating a ~lambda~ expression relative to a given environment. The resulting procedure is a pair constiting of the text of the ~lambda~ expression and the environment in which the procedure was created.

~define~ creates a binding in the current environment frame and assigns to the symbol the indicated value.
Evaluating ~set!~ in some environment locates the binding of the variable in the environment and changes that binding to the new value. That is, it finds the first frame in the environment that contains a binding for the variable and modifies that frame. If the variable is unbound in the environment, ~set!~ signals an error.

** 3.2.2 Applying Simple Procedures

... using paper ...

** 3.2.3 Frames as the Repository of Local State

... using paper ...

** 3.2.4 Internal Definitions

... using paper ...

* 3.3 Modeling with Mutable Data

Chapter 2 introduced the discipline of data abstraction - when data structures are specified in terms of data constructors and data selectors. But that does not address the desire to model systems composed of objects with changing state.

Thus, we also need to have means to update the state of compound object, in addition to constructing and selecting from them.

Now data abstraction has one additional category:
Constructors, selectors, /mutators/.

Data objects with defined mutators are known as /mutable data objects/.

** 3.3.1 Mutable List Structure

~cons~, ~car~, ~cdr~, ~append~ and ~list~ allow to construct and get information from the objects, but not to update them.

~set-car!~ and ~set-cdr!~ are the primitives for updating pairs.

*** Exercise 3.13

#+begin_src racket
  #lang sicp


  (define (last-pair x)
    (if (null? (cdr x))
	x
	(last-pair (cdr x))))

  (define (make-cycle x)
    (set-cdr! (last-pair x) x)
    x)

  (define z (make-cycle (list 'a 'b 'c)))

  z
  (last-pair z)
#+end_src

#+RESULTS[126b9da51dc3098387bbf499ed1a4a26d2b06d94]:
: #0=(a b c . #0#)

*** Exercise 3.14

#+begin_src racket
  #lang sicp

  (define (mystery x)
    (define (loop x y)
      (if (null? x)
	  y
	  (let ((temp (cdr x)))
	    (set-cdr! x y)
	    (loop temp x))))
    (loop x '()))

  (define v (list 'a 'b 'c 'd))

  (define w (mystery v))

  v

  w
  
#+end_src

#+RESULTS[47d4cec51533537464575db059a7dba12ed004e0]:
: (a)
: (d c b a)

*** Sharing and Identity

Theoretical issues of "sameness" and "change" arise in practice when individual pairs are /shared/ among different data objects.

#+begin_src racket
  (define x (list 'a 'b))
  (define z1 (cons x x))
#+end_src

~z1~ is a pair whose ~car~ and ~cdr~ both point to the same pair ~x~.

In general, using ~cons~ to construct lists will result in an interlinked structure of pairs, in which many individual pairs are shared by many different structures.

#+begin_src racket
  (define z2 (cons (list 'a 'b) (list 'a 'b)))
#+end_src

~z2~ is a pair whose ~car~ and ~cdr~ point to two distinct pairs, each having ~'a~ and ~'b~ in its cells.
In Scheme, there is a unique symbol with any given name, so symbols are shared.

Sharing is undetectable until constructors and selectors are used, but with mutators added it becomes significant.

#+begin_src racket
  (define (set-to-wow! x)
    (set-car! (car x) 'wow)
    x)
#+end_src

~(set-to-wow! z1)~ will update ~z1~ to ~((wow b) wow b)~.
~(set-to-wow! z2)~ will update ~z2~ to ~((wow b) a b)~.

~eq?~ tests whether two objects are equal as pointers.

In general, ~set-car!~ and ~set-cdr!~ should be used with full understanding how data objects are shared.

*** Exercise 3.15, 3.16

... using paper ...

*** Exercise 3.17 - count pairs in structure

#+begin_src racket
  #lang sicp


  (define (new-set) '())
  (define (empty-set? s) (null? s))
  (define (size-set s)
    (if (null? s)
	0
	(+ 1 (size-set (cdr s)))))
  (define (contains-set? s x)
    (cond ((null? s) false)
	  ((eq? (car s) x) true)
	  (else (contains-set? (cdr s) x))))
  (define (add-set s x)
    (if (contains-set? s x)
	s
	(cons x s)))
  (define (union-set s1 s2)
    (cond ((null? s1) s2)
	  ((contains-set? s2 (car s1))
	   (union-set (cdr s1) s2))
	  (else
	   (cons (car s1) (union-set (cdr s1) s2)))))

  (define (count-pairs x)
    (define (recur x seen)
      (cond ((or (not (pair? x))
		 (contains-set? seen x))
	     seen)
	    (else
	     (let ((new-seen (add-set seen x)))
	       (union-set (recur (car x) new-seen)
			  (recur (cdr x) new-seen))))))
    (size-set (recur x (new-set))))

  (count-pairs (list 'a 'b 'c))
  (count-pairs (cons (list 'a 'b) (list 'a 'b)))
  (define x (list 'a 'b))
  (count-pairs (cons x x))

  (define (last-pair xs)
    (if (null? (cdr xs))
	xs
	(last-pair (cdr xs))))

  (define (make-cycle x)
    (set-cdr! (last-pair x) x)
    x)
  (count-pairs (make-cycle x))
#+end_src

#+RESULTS[65939753e29f724c4ed434b96ead8cb90787d989]:
: 3
: 5
: 3
: 2

*** Exercise 3.18 - detect cycle

Write a procedure that examines a list and determines whether it contains a cycle.
#+begin_src racket
  #lang sicp

  (define (detect-cycle x)
    (define (iter y)
      (cond ((null? y) false)
	    ((eq? y x) true)
	    (else
	     (iter (cdr y)))))
    (if (null? x)
	false
	(iter (cdr x))))

  (define (last-pair x)
    (if (null? (cdr x))
	x
	(last-pair (cdr x))))

  (define (make-cycle x)
    (set-cdr! (last-pair x) x)
    x)

  (detect-cycle (make-cycle '(a b c)))
  (detect-cycle '(a b c))
#+end_src

#+RESULTS[c1c6cdb773afb181fd21b32badbdf3c318dac70b]:
: #t
: #f

*** Exercise 3.19 - detect cycle in constant space

My solution in 3.18 already consumes constant space besides the size of the input list.

*** Mutation is just assignment

#+begin_src racket
  (define (cons x y)
    (define (set-x! v) (set! x v))
    (define (set-y! v) (set! y v))
    (define (dispatch m)
      (cond ((eq? m 'car) x)
	    ((eq? m 'cdr) y)
	    ((eq? m 'set-car!) set-x!)
	    ((eq? m 'set-cdr!) set-y!)
	    (else (error "Unknown message -- CONS" m))))
    dispatch)

  (define (car x) (x 'car))
  (define (cdr x) (x 'cdr))
  (define (set-car! x v) ((x 'set-car!) v))
  (define (set-cdr! x v) ((x 'set-cdr!) v))
#+end_src

~Cons~ can be implemented using only ~set!~ and local state.

*** Exercise 3.20 - environment diagrams for ~cons~

#+attr_html: :width 100%
[[./images/Exercise-3.20.jpeg]]

** 3.3.2 Representing Queues

A /queue/ is a sequence in which items are inserted at one end (the /rear/ of the queue) and deleted from the other end (the /front/).

Queue operations:
#+begin_src racket
  (define q (make-queue))

  (insert-queue! q 'a)  ;; a
  (insert-queue! q 'b)  ;; a b
  (delete-queue! q)     ;; b
  (insert-queue! q 'c)  ;; b c
  (insert-queue! q 'd)  ;; b c d
  (delete-queue! q)     ;; c d
#+end_src

Data abstraction:
- a constructor
  
  ~(make-queue)~ - returns an empty queue
- two selectors
  
  ~(empty-queue? <queue>)~ - tests if the queue is empty
  ~(front-queue <queue>)~ - returns the object at the front of the queue, or signals an error if the queue is empty; does not modify the queue
- two mutators
  
  ~(insert-queue! <queue> <item>)~ - insert the item at the rear of the queue and return mutated queue
  ~(delete-queue! <queue>)~ - remove the item at the front of the queue and return mutated queue; signals an error if the queue is empty before the deletion

We could represent a queue as a list - let the ~car~ of the list be the front end of the queue, and the last item of the lis be the rear end of the queue. Then to delete an item would just mean taking ~car~ of a list, and inserting a new element would mean appending it at the end of the list.

With list, though, it would take $O(n)$ steps to find append an element, which is inefficient.

To overcome this inefficiency we can store the pointer to the last pair of the list. Then to insert an element we can consult the rear pointer and avoid scanning the list.

A queue represented then as a pair of pointers ~front-ptr~ and ~rear-ptr~, which indicate, respectively, the first and the last pair in the queue. We can use ~cons~ to combine two pointers.

#+name: 3.3.1-queue-primitives
#+begin_src racket
  (define (front-ptr queue) (car queue))
  (define (rear-ptr queue) (cdr queue))
  (define (set-front-ptr! queue item) (set-car! queue item))
  (define (set-rear-ptr! queue item) (set-cdr! queue item))
#+end_src

#+name: 3.3.1-queue-interface
#+begin_src racket
  <<3.3.1-queue-primitives>>
  (define (make-queue) (cons '() '()))
  (define (empty-queue? queue) (null? (front-ptr queue)))
  (define (front-queue queue)
    (if (empty-queue? queue)
	(error "FRONT called with an empty queue" queue)
	(car (front-ptr queue))))

  (define (insert-queue! queue element)
    (let ((item (cons element '())))
      (cond ((empty-queue? queue)
	     (set-front-ptr! queue item)
	     (set-rear-ptr! queue item)
	     queue)
	    (else
	     (set-cdr! (rear-ptr queue) item)
	     (set-rear-ptr! queue item)
	     queue))))

  (define (delete-queue! queue)
    (if (empty-queue? queue)
	(error "DELETE called with an empty queue" queue)
	(begin
	  (set-front-ptr! queue (cdr (front-ptr queue)))
	  queue)))

  (define q (make-queue))
#+end_src

#+begin_src racket :exports both
  #lang sicp
  <<3.3.1-queue-interface>>
  (insert-queue! q 'a)  ;; a
  (insert-queue! q 'b)  ;; a b
  (delete-queue! q)     ;; b
  (insert-queue! q 'c)  ;; b c
  (insert-queue! q 'd)  ;; b c d
  (delete-queue! q)     ;; c d
#+end_src

#+RESULTS[80008d863a89eb6dbd2ca24afeb4daaa190e7ac7]:
: ((a) a)
: ((a b) b)
: ((b) b)
: ((b c) c)
: ((b c d) d)
: ((c d) d)

*** Exercise 3.21 - queue print representation
Problem: "Last element inserted into the queue twice. After deleting all items, ~'b~ is still there, so queue is not empty".

Problem reproduction example:
#+begin_src racket :exports both
  #lang sicp
  <<3.3.1-queue-interface>>
  (define q1 (make-queue))
  (insert-queue! q1 'a)
  (insert-queue! q1 'b)
  (delete-queue! q1)
  (delete-queue! q1)
#+end_src

#+RESULTS[6b5642228a685b896a8d60a4052006e11265128c]:
: ((a) a)
: ((a b) b)
: ((b) b)
: (() b)

**** Show why example produces the output it does
Queue is represented as a cons, with the cdr being the pointer to the rear of the queue. While the rear-ptr is not cleaned up after deleting the last element of the queue, there is no way to access it through the public interface.

**** Define a ~print-queue~ procedure

#+name: ex3.22-print-queue
#+begin_src racket
  (define (print-queue queue)
    (display (car queue))
    (newline))
#+end_src

#+begin_src racket :exports both
  #lang sicp
  <<3.3.1-queue-interface>>
  <<ex3.22-print-queue>>
  (define q1 (make-queue))
  (print-queue (insert-queue! q1 'a))
  (print-queue (insert-queue! q1 'b))
  (print-queue (delete-queue! q1))
  (print-queue (delete-queue! q1))
#+end_src

#+RESULTS[c7aba7ae23a075101cd08ce3f8b9edc1fb205270]:
: (a)
: (a b)
: (b)
: ()

*** Exercise 3.23 - /deque/

Interface:
- ~(make-deque)~
- ~(front-deque q)~
- ~(rear-deque q)~
- ~(insert-front-deque q)~
- ~(delete-front-deque q)~
- ~(insert-rear-deque q)~
- ~(delete-rear-deque q)~

All operations should take $O(1)$ time.

Similarly to the queue list-based implementation, we need to store the rear pointer. Unlike in the queue, each spot should also store the pointer to the previous spot, so in ~(delete-rear-deque q)~ we can efficiently update the rear pointer.



#+name: ex-3.23-deque
#+begin_src racket
  ;; private procedures
  (define (front-ptr d) (car d))
  (define (rear-ptr d) (cdr d))
  (define (set-front-ptr! d spot) (set-car! d spot))
  (define (set-rear-ptr! d spot) (set-cdr! d spot))

  ;; (define (make-spot v prev next) (cons v (cons prev next)))
  ;; (define (value spot) (car spot))
  ;; (define (prev-spot spot) (cadr spot))
  ;; (define (next-spot spot) (cddr spot))
  ;; (define (set-prev-spot! spot prev) (set-car! (cdr spot) prev))
  ;; (define (set-next-spot! spot next) (set-cdr! (cdr spot) next))

  (define (make-spot v prev next) (cons v (cons prev (cons next '()))))
  (define (value spot) (car spot))
  (define (prev-spot spot) (cadr spot))
  (define (next-spot spot) (caddr spot))
  (define (set-prev-spot! spot prev) (set-car! (cdr spot) prev))
  (define (set-next-spot! spot next) (set-car! (cddr spot) next))

  ;; public interface
  (define (make-deque) (cons '() '()))
  (define (empty-deque? d) (null? (front-ptr d)))
  (define (front-deque d) (value (front-ptr d)))
  (define (rear-deque d) (value (rear-ptr d)))

  (define (insert-front-deque! d v)
    (let ((spot (make-spot v '() '())))
      (if (empty-deque? d)
	  (begin
	    (set-front-ptr! d spot)
	    (set-rear-ptr! d spot)
	    d)
	  (begin
	    (set-next-spot! spot (front-ptr d))
	    (set-prev-spot! (front-ptr d) spot)
	    (set-front-ptr! d spot)
	    d))))

  (define (insert-rear-deque! d v)
    (let ((spot (make-spot v '() '())))
      (if (empty-deque? d)
	  (begin
	    (set-front-ptr! d spot)
	    (set-rear-ptr! d spot)
	    d)
	  (begin
	    (set-prev-spot! spot (rear-ptr d))
	    (set-next-spot! (rear-ptr d) spot)
	    (set-rear-ptr! d spot)
	    d))))

  (define (delete-front-deque! d)
    (cond ((empty-deque? d) (error "DELETE called with empty queue" d))
	  ((null? (next-spot (front-ptr d)))
	   (set-front-ptr! d '())
	   (set-rear-ptr! d '())
	   d)
	  (else
	   (let ((new-front (next-spot (front-ptr d))))
	     (set-next-spot! (front-ptr d) '())
	     (set-prev-spot! new-front '())
	     (set-front-ptr! d new-front)
	     d))))

  (define (delete-rear-deque! d)
    (cond ((empty-deque? d) (error "DELETE called with empty queue" d))
	  ((null? (prev-spot (rear-ptr d)))
	   (set-front-ptr! d '())
	   (set-rear-ptr! d '()))
	  (else
	   (let ((new-rear (prev-spot (rear-ptr d))))
	     (set-prev-spot! (rear-ptr d) '())
	     (set-next-spot! new-rear '())
	     (set-rear-ptr! d new-rear)
	     d))))

  (define (print-deque d)
    (define (iter spot vals)
      (if (null? spot)
	  vals
	  (iter (prev-spot spot) (cons (value spot) vals))))
    (display (iter (rear-ptr d) '()))
    (newline))
#+end_src

#+begin_src racket :exports both
  #lang sicp

  <<ex-3.23-deque>>

  (define d (make-deque))
  d
  (print-deque (insert-front-deque! d 'a))
  (print-deque (insert-rear-deque! d 'b))
  (print-deque (insert-rear-deque! d 'c))
  (print-deque (delete-front-deque! d))
  (print-deque (delete-rear-deque! d))
  (print-deque (delete-front-deque! d))
  d
  ;; (print-deque (delete-front-deque! d))
  (print-deque (insert-front-deque! d 'a))
  (print-deque (insert-front-deque! d 'b))
  (print-deque (insert-front-deque! d 'c))
  (print-deque (insert-front-deque! d 'd))
  (print-deque (insert-front-deque! d 'e))
  (print-deque (insert-front-deque! d 'f))
  (front-deque d)
  (rear-deque d)
  d
  (print-deque (insert-rear-deque! d '0))
  (print-deque (delete-front-deque! d))
  (print-deque (delete-front-deque! d))
  (print-deque (delete-front-deque! d))
  (print-deque (delete-front-deque! d))
  (print-deque (delete-front-deque! d))
  (print-deque (delete-front-deque! d))
  (print-deque (delete-front-deque! d))
  d
#+end_src

#+RESULTS[80a6c227688ffe92d22bcf64f2137c5e644308ac]:
#+begin_example
(())
(a)
(a b)
(a b c)
(b c)
(b)
()
(())
(a)
(b a)
(c b a)
(d c b a)
(e d c b a)
(f e d c b a)
f
a
(#0=(f () #1=(e #0# #2=(d #1# #3=(c #2# #4=(b #3# #5=(a #4# ())))))) . #5#)
(f e d c b a 0)
(e d c b a 0)
(d c b a 0)
(c b a 0)
(b a 0)
(a 0)
(0)
()
(())
#+end_example

** 3.3.3 Representing Tables

How to build tables as mutable data structures (e.g. as used in 2.4.3).

We implement the table as a list of records, each of which is implemented as a pair consisting of a key and the associated value.

*** One-dimensional table

The records are glued together to form a list by pairs whose ~cars~ point to successive records. These gluing paris are called the /backbone/ of the table.

In order to have a place that we can change when we add a new record to the table, we build the table as a /headed list/ - it has a special backbone pair at the beginning, which holds a dummy "record".

To find a value by key, ~(lookup key table)~ procedure is used. It returns the value or ~false~ if no key exists in the table. ~lookup~ uses ~assoc~ procedure that find the record associated with the key. ~assoc~ scans through the backbone pairs checking if each pair's record is associated with the key. In no such records exist, it returns false. ~assoc~ never touches the head of the list, working only on backbone pairs that point to real records.

To insert ~(insert! key value table)~ procedure is used. It also uses ~assoc~ to locate the record. If it exists then the value is updated using ~set-cdr!~. Otherwise a new record and a backbone pair created and inserted after the head of the list. Head of the list is important to have a stable position a table variable can point to: if the new record is inserted at the beginning of the list, ~insert!~ would have to return a new pointer to the start of the table when adding a new record.

#+name: 3.3.3-table1
#+begin_src racket
  (define (assoc key records)
    (cond
      ((null? records) false)
      ((eq? key (caar records)) (car records))
      (else (assoc key (cdr records)))))

  (define (lookup key table)
    (let ((record (assoc key (cdr table))))
      (if record
	  (cdr record)
	  false)))

  (define (insert! key value table)
    (let ((record (assoc key (cdr table))))
      (if record
	  (set-cdr! record value)
	  (set-cdr! table
		    (cons (cons key value)
			  (cdr table))))))

  (define (make-table)
    (cons '*table* '()))
#+end_src

#+begin_src racket :exports both
  #lang sicp

  <<3.3.3-table1>>

  (define t (make-table))
  (insert! 'a 1 t)
  (insert! 'b 2 t)
  (insert! 'c 3 t)
  (insert! 'd 4 t)

  (lookup 'a t)
  (lookup 'd t)
  (lookup 'e t)
#+end_src

#+RESULTS[6f5b91ea07d637d0b5cbde41d75bcf4ddd6e6961]:
: 1
: 4
: #f

*** Two-dimensional tables

Each value is indexed by two keys. We can construct such table by having a single-key table indexing the first key whose ~car~ are single-key subtables indexing the second key. The subtables does not need a special header pair, as the key pair of the main table serves as one.

#+name: 3.3.3-table2
#+begin_src racket
  (define (assoc key records)
    (cond ((null? records) false)
	  ((eq? key (caar records)) (car records))
	  (else (assoc key (cdr records)))))


  (define (lookup key-1 key-2 table)
    (let ((subtable (assoc key-1 (cdr table))))
      (if subtable
	  (let ((record (assoc key-2 (cdr subtable))))
	    (if record
		(cdr record)
		false))
	  false)))


  (define (insert! key-1 key-2 value table)
    (let ((subtable (assoc key-1 (cdr table))))
      (if subtable
	  (let ((record (assoc key-2 (cdr subtable))))
	    (if record
		(set-cdr! record value)
		(set-cdr! subtable
			  (cons (cons key-2 value)
				(cdr subtable)))))
	  (set-cdr! table
		    (let* ((new-record (cons key-2 value))
			   (new-subtable (cons new-record '())))
		      (cons (cons key-1 new-subtable)
			    (cdr table))))))
    'ok)

  (define (make-table)
    (cons '*table* '()))
#+end_src

#+begin_src racket :tangle "two-key-table-test.rkt"
  #lang sicp

  <<3.3.3-table2>>

  (define t (make-table))
  (insert! 'a 'a1 10 t)
  (insert! 'a 'a2 11 t)
  (insert! 'a 'a3 12 t)
  (insert! 'a 'a4 13 t)
  (insert! 'b 'b1 20 t)
  (insert! 'b 'b2 21 t)
  (insert! 'b 'b3 22 t)

  (lookup 'a 'a1 t)
  (lookup 'a 'a4 t)
  (lookup 'a 'a5 t)
  (lookup 'b 'b1 t)
  (lookup 'b 'b3 t)
  (lookup 'b 'b4 t)
  (lookup 'c 'c1 t)
#+end_src

#+RESULTS[4daf85ea3ece85a21a661ac13eaa48d0aa72bf10]:
#+begin_example
ok
ok
ok
ok
ok
ok
ok
10
13
#f
20
22
#f
#f
#+end_example

*** Creating local tables

#+name: 3.3.3-table2-object
#+begin_src racket
  (define (assoc key records)
    (cond ((null? records) false)
	  ((eq? key (caar records)) (car records))
	  (else (assoc key (cdr records)))))


  (define (make-table)
    (let ((table (cons '*table* '())))
      (define (lookup key-1 key-2)
	(let ((subtable (assoc key-1 (cdr table))))
	  (if subtable
	      (let ((record (assoc key-2 (cdr subtable))))
		(if record
		    (cdr record)
		    false))
	      false)))
      (define (insert! key-1 key-2 value)
	(let ((subtable (assoc key-1 (cdr table))))
	  (if subtable
	      (let ((record (assoc key-2 (cdr subtable))))
		(if record
		    (set-cdr! record value)
		    (set-cdr! subtable (cons (cons key-2 value)
					     (cdr subtable)))))
	      (set-cdr! table
			(let* ((new-record (cons key-2 value))
			       (new-subtable-records (cons new-record '()))
			       (new-subtable (cons key-1 new-subtable-records)))
			  (cons new-subtable
				(cdr table)))))))
      (define (dispatch m)
	(cond ((eq? m 'lookup) lookup)
	      ((eq? m 'insert!) insert!)
	      (else (error "Unknown method -- TABLE" m))))
      dispatch))
#+end_src

#+begin_src racket :exports both
  #lang sicp

  <<3.3.3-table2-object>>

  (define t (make-table))
  ((t 'insert!) 'a 'a1 10)
  ((t 'insert!) 'a 'a2 11)
  ((t 'insert!) 'a 'a3 12)
  ((t 'insert!) 'a 'a4 13)
  ((t 'insert!) 'b 'b1 20)
  ((t 'insert!) 'b 'b2 21)
  ((t 'insert!) 'b 'b3 22)

  ((t 'lookup) 'a 'a1)
  ((t 'lookup) 'a 'a4)
  ((t 'lookup) 'a 'a5)
  ((t 'lookup) 'b 'b1)
  ((t 'lookup) 'b 'b3)
  ((t 'lookup) 'b 'b4)
  ((t 'lookup) 'c 'c1)
#+end_src

#+RESULTS[575a4e78a785c7fbfa98c3e1babf86d428474931]:
: 10
: 13
: #f
: 20
: 22
: #f
: #f


*** Exercise 3.24 - user-provided key comparison function
Design a table constructor ~make-table~ that takes as an argument a ~same-key?~ procedure that will be used to test "equality" of keys.

#+name: ex3.24-table2-same-key?
#+begin_src racket
  (define (make-table same-key?)
    (define (assoc key records)
      (cond ((null? records) false)
	    ((same-key? key (caar records)) (car records))
	    (else (assoc key (cdr records)))))
    (let ((table (cons '*table* '())))
      (define (lookup key-1 key-2)
	(let ((subtable (assoc key-1 (cdr table))))
	  (if subtable
	      (let ((record (assoc key-2 (cdr subtable))))
		(if record
		    (cdr record)
		    false))
	      false)))
      (define (insert! key-1 key-2 value)
	(let ((subtable (assoc key-1 (cdr table))))
	  (if subtable
	      (let ((record (assoc key-2 (cdr subtable))))
		(if record
		    (set-cdr! record value)
		    (set-cdr! subtable (cons (cons key-2 value)
					     (cdr subtable)))))
	      (set-cdr! table
			(let* ((new-record (cons key-2 value))
			       (new-subtable-records (cons new-record '()))
			       (new-subtable (cons key-1 new-subtable-records)))
			  (cons new-subtable (cdr table))))))
	'ok)
      (define (dispatch m)
	(cond ((eq? m 'lookup-proc) lookup)
	      ((eq? m 'insert!-proc) insert!)
	      (else (error "Unknown method -- TABLE" m))))
      dispatch))
#+end_src

#+begin_src racket :exports both
  #lang sicp

  <<ex3.24-table2-same-key?>>

  (define t (make-table eq?))
  ((t 'insert!-proc) 'a 'a1 10)
  ((t 'insert!-proc) 'a 'a2 11)
  ((t 'insert!-proc) 'a 'a3 12)
  ((t 'insert!-proc) 'a 'a4 13)
  ((t 'insert!-proc) 'b 'b1 20)
  ((t 'insert!-proc) 'b 'b2 21)
  ((t 'insert!-proc) 'b 'b3 22)

  ((t 'lookup-proc) 'a 'a1)
  ((t 'lookup-proc) 'a 'a4)
  ((t 'lookup-proc) 'a 'a5)
  ((t 'lookup-proc) 'b 'b1)
  ((t 'lookup-proc) 'b 'b3)
  ((t 'lookup-proc) 'b 'b4)
  ((t 'lookup-proc) 'c 'c1)

  (define t2 (make-table (lambda (k1 k2)
			   (cond ((and (number? k1) (number? k2))
				  (< (abs (- k1 k2)) 0.0001))
				 (else
                                  (equal? k1 k2))))))
  ((t2 'insert!-proc) 0.001 'a1 10)
  ((t2 'lookup-proc) 0.00105 'a1)
  ((t2 'lookup-proc) 0.002 'a1)
#+end_src

#+RESULTS[9132de42dc44f340bc7174bf7a3c8044be9e7118]:
#+begin_example
ok
ok
ok
ok
ok
ok
ok
10
13
#f
20
22
#f
#f
ok
10
#f
#+end_example

*** Exercise 3.25 - table-x

Generalizing one- and two-dimensional tables, show how to implement a table in which values are stored under an arbitrary number of keys and different values may be stored under different number of keys. The ~lookup~ and ~insert!~ procedures should take as an input a list of keys used to access the table.

-----

There are two complications:
1. recursive access to the record
2. a key prefix can contain a value /and/ a subtable

To address #2 we can model a record with three values, key, value, subtable, where value and subtable are both optional.
Records operations are abstracted with a private interface - ~make-record~, ~key-record~, ~value-record~, ~subtable-record~, ~set-value-record!~ and ~set-subtable-record!~.
They are implemented using list of 3 items, ~'(key value subtable)~ and respective accessors/mutators.

Similarly to table1 and table2, table-x is implemented as a headed list, with top-level head resembling a record for uniformity.

Publicly exposed functions ~lookup~ and ~insert!~ validate that ~keys~ list is not empty, and call recursive implementations, ~lookup-rec~ and ~insert-rec!~ respectively.

~lookup-rec~ tries to find a record associated with the first key in ~keys~ in the ~parent~ subtable. If there are none, no value with associated ~keys~ exists in the table and it returns ~false~. If there is a record, 3 cases are possible:
- this is the last part of the key and the record has a value, then return the value,
- this is the last part of the key and the record has no value (record only has subtable), the return ~false~,
- this is not the last part of the key, then recursively call ~lookup-rec~ on this record with the rest of the keys.

~insert-rec!~ tries to find a record associated with the first key in ~keys~ in the ~parent~ subtable. If there are none, helper ~create!~ is called that will recursively insert all missing records and backbone pairs. If there is a record and it's the final key, update the value in this record. Finally, if there is a record and there are more keys, call ~insert-rec!~ on the record with the rest of the keys.

~(create! keys value parent)~ helper creates a new record and a new backbone pair, and inserts the pair into ~parent~'s backbone. If this is the final key, update the new record's value, otherwise recursively ~create!~ nested structures starting from the record.

To easily inspect the table, ~(collect-rec parent keys-prefix acc)~ procedure can be used. ~collect-rec~ essentially implements a depth-first search, tracking the ~keys-prefix~ and accumulating ~(keys . value)~ pairs if a record with the value was reached (but not stopping there).

#+name: ex3.25-table-x
#+begin_src racket
  (define (make-table-x)
    (define (make-record key value subtable)
      (list key value subtable))
    (define (key-record r) (car r))
    (define (value-record r) (cadr r))
    (define (subtable-record r) (caddr r))
    (define (set-value-record! r v) (set-car! (cdr r) v))
    (define (set-subtable-record! r v) (set-car! (cddr r) v))

    (define (assoc key backbone)
      (cond ((null? backbone) false)
	    ((eq? key (caar backbone)) (car backbone))
	    (else (assoc key (cdr backbone)))))

    (define (lookup-rec keys parent)
      (let ((record (assoc (car keys) (subtable-record parent))))
	(cond ((not record) false)
	      ((null? (cdr keys))
	       (if (null? (value-record record))
		   false
		   (value-record record)))
	      (else (lookup-rec (cdr keys) record)))))

    (define (create! keys value parent)
      (let* ((new-record (make-record (car keys) '() '()))
	     (new-subtable (cons new-record (subtable-record parent))))
	(set-subtable-record! parent new-subtable)
	(if (null? (cdr keys))
	    (set-value-record! new-record value)
	    (create! (cdr keys) value new-record))))

    (define (insert-rec! keys value parent)
      (let ((record (assoc (car keys) (subtable-record parent))))
	(cond ((not record)
	       (create! keys value parent))
	      ((null? (cdr keys))
	       (set-value-record! record value))
	      (else
	       (insert-rec! (cdr keys) value record))))
      'ok)

    (define (collect-rec parent keys-prefix acc)
      (define (iter backbone acc)
	(if (null? backbone)
	    acc
	    (let* ((record (car backbone))
		   (keys-prefix-1 (cons (key-record record) keys-prefix))
		   (acc-1 (collect-rec record
				       keys-prefix-1
				       (if (null? (value-record record))
					   acc
					   (cons (cons (reverse keys-prefix-1)
						       (value-record record))
						 acc)))))
	      (iter (cdr backbone) acc-1))))
      (iter (subtable-record parent) acc))

    (let ((root (make-record '*table* '() '())))
      (define (lookup keys)
	(if (null? keys)
	    (error "Empty keys")
	    (lookup-rec keys root)))
      (define (insert! keys value)
	(if (null? keys)
	    (error "Empty keys")
	    (insert-rec! keys value root)))
      (define (print-table)
	(display (collect-rec root '() '()))
	(newline))

      (define (dispatch m)
	(cond ((eq? m 'lookup) lookup)
	      ((eq? m 'insert!) insert!)
	      ((eq? m 'print) (print-table))
	      (else (error "Unknown method -- TABLE-X" m))))
      dispatch))
#+end_src

#+RESULTS[d13466ca3793e7393455065418654883ccdc4926]:

#+begin_src racket :tangle ex3.25-table-x.rkt :exports both
  #lang sicp

  <<ex3.25-table-x>>

  (define tab (make-table-x))

  ((tab 'insert!) (list 'a) 10)
  (tab 'print)
  ((tab 'insert!) (list 'a 'a1) 11)
  ((tab 'lookup) (list 'a))
  ((tab 'lookup) (list 'a 'a1))
  ((tab 'insert!) (list 'a 'a1 'a2 'a3) 12)
  ((tab 'lookup) (list 'a))
  ((tab 'lookup) (list 'a 'a1))
  ((tab 'lookup) (list 'a 'a1 'a2))
  (tab 'print)
  ((tab 'lookup) (list 'a 'a1 'a2 'a3))
  ((tab 'insert!) (list 'a 'a1 'a2) 13)
  ((tab 'insert!) (list 'b) 10)
  ((tab 'insert!) (list 'b 'a1) 11)
  ((tab 'insert!) (list 'b 'a1 'a2 'a3) 12)
  ((tab 'insert!) (list 'b 'a1 'a2) 13)
  ((tab 'lookup) (list 'b 'a1))
  (tab 'print)
#+end_src

#+RESULTS[58629191db689199df73813ed6547b2d14405c74]:
#+begin_example
ok
(((a) . 10))
ok
10
11
ok
10
11
#f
(((a a1 a2 a3) . 12) ((a a1) . 11) ((a) . 10))
12
ok
ok
ok
ok
ok
11
(((a a1 a2 a3) . 12) ((a a1 a2) . 13) ((a a1) . 11) ((a) . 10) ((b a1 a2 a3) . 12) ((b a1 a2) . 13) ((b a1) . 11) ((b) . 10))
#+end_example
